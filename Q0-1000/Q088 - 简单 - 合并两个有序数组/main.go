package main

import "fmt"

func main() {
	nums1 := []int{1, 2, 3, 0, 0, 0}
	m := 3
	nums2 := []int{2, 5, 6}
	n := 3
	merge(nums1, m, nums2, n)
	fmt.Println(nums1)
}

// 解题思路
// 从后往前遍历两个数组，把大的数值放在nums1的末尾，大数值的数组索引-1，nums1的末尾索引-1
// 重新执行上述步骤，直到一个数组遍历完毕
// 若nums2还有剩余元素，将剩余元素放在nums1的前端

// 解题步骤
// 1、定义 x,y,z 3个位置索引，分别指向num1的m元素位置，num2与num3的数组末尾位置
// 2、nums1,nums2两个数组的x,y元素，比较大小，将大的数值放在nums1的z的位置，然后将大数值的索引值(x或y)-1，并将z-1
// 3、重复2步骤，直到x或y小于0
// 4、若y>=0将nums2剩余的元素，放在nums1的前面

func merge(nums1 []int, m int, nums2 []int, n int) {
	x := m - 1
	y := n - 1
	z := m + n - 1
	for x >= 0 && y >= 0 {
		if nums1[x] > nums2[y] {
			nums1[z] = nums1[x]
			x--
		} else {
			nums1[z] = nums2[y]
			y--
		}
		z--
	}
	for y >= 0 {
		nums1[z] = nums2[y]
		y--
		z--
	}
}

// 时间复杂度
// 第一个循环：这个循环继续直到 x 或 y 其中一个小于 0。因为 x 和 y 分别是 nums1 和 nums2 的末尾索引，这个循环最多执行 m + n 次（m 和 n 分别是 nums1 和 nums2 的长度）。因此，这部分的时间复杂度是 O(m + n)。
// 第二个循环：这个循环只有在 y >= 0 时执行，即只有当 nums2 中还有未合并的元素时。这个循环最多执行 n 次。但是，这部分的执行是第一个循环的一部分，不会增加总的时间复杂度。
// 综上所述，整个函数的时间复杂度是 O(m + n)。

// 空间复杂度
// 这个函数在执行过程中没有使用额外的存储空间（除了几个用于计数的变量 x、y、z），这些变量的空间占用是常数级别的。因此，空间复杂度是 O(1)。
